# NODE INFO
GET /
# CLUSTER HEALTH
GET _cluster/health
# LIST OF NODES IN CLUSTER
GET /_cat/nodes?v
# CREATE EMPTY INDEX
PUT /example
# LIST ALL INDEXES
GET _cat/indices?v
# DELETE CREATED INDEX
DELETE /example
# DELETE ALL INDEXES
DELETE /_all

# ADD DATA (CREATE DOCUMENT)
PUT /docusafe/invoice/1
{
  "#id": 1,
  "cdate": "2016-06-27",
  "number": "FV3423/16",
  "amount": 165.78,
  "remark": "Invoice has been paid",
  "tags": [
    "vat",
    "new",
    "test"
  ],
  "items": {
    "1": {
      "name": "Keyboard"
    }
  }
}
PUT /docusafe/invoice/2
{
  "#id": 2,
  "cdate": "2016-06-28",
  "number": "FV1444/16",
  "amount": 23.78,
  "remark": "Paid before march",
  "tags": [
    "vat",
    "new",
    "customer-only"
  ]
}
PUT /docusafe/invoice/3
{
  "#id": 3,
  "cdate": "2016-07-05",
  "number": "2232/15",
  "amount": 99,
  "tags": [
    "year"
  ]
}

# ID GENERATED BY ELASTICSEARCH
# THIS DOESN'T WORK
PUT /docusafe/invoice
{
    "#id": 4,
    "number" : "FV 88/15",
    "amount" :  114.00,
    "remark": "Generated automatically id"
}
# THIS WORK (with POST)
POST /docusafe/invoice
{
    "#id": 4,
    "number" : "FV 88/15",
    "amount" :  114.00,
    "remark": "Generated automatically id"
}

# GET DATA

GET /docusafe/invoice/1
GET /docusafe/invoice/15
GET /docusafe/invoice/1/_source

GET /docusafe/invoice/_search
GET /docusafe/_search

#DELETE /docusafe/invoice/1
GET /docusafe/invoice/1


# MODIFY DATA (OVERRIDE ENTIRE DOCUMENT)
PUT /docusafe/invoice/1
{
    "amount" :  200.00
}
# MODIFY DATA (PARTIAL UPDATE)
POST /docusafe/invoice/1/_update
{
  "doc": {
    "amount": 200
  }
}
# MODIFY DATA - DYNAMIC SCRIPTS
POST /docusafe/invoice/1/_update
{
  "script": "ctx._source.amount+=100"
}

DELETE /docusafe
PUT /docusafe
GET /docusafe/_search
# UPDATING DOCUMENT THAT MAY NOT EXIST (UPSERT)
POST /docusafe/invoice/1/_update
{
   "script": "ctx._source.views+=1",
   "upsert": {
       "views": 1
   }
}
# CREATE OR DELETE FIELD WITHIN DOCUMENT
POST docusafe/invoice/1/_update
{
  "script": "ctx._source.remove(\"views\")"
}

GET /docusafe/invoice/1

DELETE /_all

# BULK INDEX (the new lines for action/metadata are required)
POST /_bulk
{"index":{"_index":"docusafe","_type":"invoice","_id":"1"}}
{"#id":1,"cdate":"2016-06-27","number":"FV3423/16","amount":165.7,"remark":"Invoice has been paid","tags":["vat","new","test"],"items":{"1":{"name":"Keyboard"}}}
{"index":{"_index":"docusafe","_type":"invoice","_id":"2"}}
{"#id":2,"cdate":"2016-06-28","number":"FV1444/16","amount":23.78,"remark":"Paid before march","tags":["vat","new","customer-only"]}
{"index":{"_index":"docusafe","_type":"invoice","_id":"3"}}
{"#id":3,"cdate":"2016-07-05","number":"2232/15","amount":99,"tags":["year"]}

# MULTIPLE GET
GET /_mget
{
   "docs" : [
      {
         "_index" : "docusafe",
         "_type" :  "invoice",
         "_id" :    1
      },
      {
         "_index" : "docusafe",
         "_type" :  "invoice",
         "_id" :    2,
         "_source": "cdate"
      }
   ]
}

GET /docusafe/invoice/_mget
{
   "ids" : [ "1", "2", "3" ]
}

# SEARCH BASIC DATA
GET /docusafe/invoice/_search

GET /docusafe/_search?q=remark:paid+before
GET /docusafe/_search?q=cdate:2016
GET /docusafe/_search?q=cdate:2016-06-27

GET /docusafe/invoice/_search
{
  "query": { "match_all": {} }
}

# Finding individual words within field
GET /docusafe/invoice/_search
{
    "query" : {
        "match" : {
            "remark" : "has been paid"
        }
    }
}

# Match exact sentence
GET /docusafe/invoice/_search
{
    "query" : {
        "match_phrase" : {
            "remark" : "has been paid"
        }
    }
}


GET /docusafe/invoice/_search
{
  "query": {
    "constant_score": {
      "filter": {
        "range": {
          "cdate": {
            "gt": "2016-07-01"
          }
        }
      }
    }
  }
}

# SIMPLE AGGREGATIONS
GET /docusafe/invoice/_search
{
  "size": 0,
  "aggs": {
    "tags_counter": {
      "terms": { "field": "tags" }
    }
  }
}

GET /docusafe/invoice/_search
{
  "size": 0,
  "aggs": {
    "tags_counter": {
      "terms": {
        "field": "tags"
      },
      "aggs": {
        "avg_age": {
          "avg": {
            "field": "amount"
          }
        }
      }
    }
  }
}

# BASIC TEXT ANALYSIS - THEORY AND PRACTICE

#The query-string search uses the _all field unless another field name has been specified.

GET docusafe/invoice/_search?q=2016
GET docusafe/invoice/_search?q=2016-07-05
GET docusafe/invoice/_search?q=cdate:2016
GET docusafe/invoice/_search?q=cdate:2016-07-05

GET /docusafe/_mapping/invoice

# USING BUILD-IN ANALYZER
GET /_analyze
{
  "analyzer": "standard",
  "text": "Quick brown fox and dogs 4-6"
}
GET /_analyze
{
  "analyzer" : "whitespace",
  "text" : " this is a test 4-6"
}

# using custom transient analyzer out of tokenizers, token filters and char filters (token filters can use the shorter 'filter' parameter name)
# keyword tokenizer -  emits the entire input as a single output.
GET _analyze
{
  "tokenizer" : "keyword",
  "filter" : ["lowercase"],
  "text" : "This is a Test"
}

GET _analyze
{
  "tokenizer" : "keyword",
  "token_filter" : ["lowercase"],
  "char_filter" : ["html_strip"],
  "text" : "this is a <b>test</b>"
}

GET /_analyze
{
  "tokenizer" : "standard",
  "token_filter" : ["snowball"],
  "text" : "detailed output",
  "explain" : true
}

# MAPPINGS
GET /docusafe/_mapping/invoice

DELETE /twitter
PUT /twitter
{
  "mappings": {
    "tweets" : {
      "properties" : {
        "content" : {
          "type" :    "string",
          "analyzer": "english"
        },
        "date" : {
          "type" :   "date"
        },
        "name" : {
          "type" :   "string",
          "index": "not_analyzed"
        },
        "user_id" : {
          "type" :   "long",
          "index": "no"
        }
      }
    }
  }
}

GET /twitter/_mappings
PUT /twitter/tweets/1
{
  "user_id": 1,
  "name": "Test name",
  "date": "2016-07-05",
  "content": "It is a great training"
}
GET /twitter/tweets/1

### YOU CANNOT CHANGE A FIELD TYPE !
PUT /twitter/tweets/_mapping
{
    "tweets" : {
      "properties" : {
        "user_id" : {
          "type" :   "string"
        }
      }
    }
}

# WHY USE MAPPINGS (?)
POST /logs/transactions
{
  "id": 25
}
POST /logs/transactions
{
  "id": 27.25
}

GET /logs/transactions/_search

GET /logs/transactions/_search
{
  "query": {
    "bool": {
      "filter": {
        "range": {
          "id": {
            "gt": 27,
            "lt": 28
          }
        }
      }
    }
  }
}

GET /logs/_mappings
GET /logs/_search
# Testing the existing mapping
GET /twitter/_analyze
{
  "field": "name",
  "text": "Black-cats jumping high"
}
GET /twitter/_analyze
{
  "field": "content",
  "text": "Black-cats jumping high"
}

# COMPLEX CORE FIELD TYPES (no special mapping, but the types inside the array have to be the same)
POST /library/book
{
  "tag": ["history", "fiction"]
}
GET /library/_mappings

# object type
POST /db/users
{
  "firstname": "Jan",
  "lastname": "Kowalski",
  "address": {
    "street": "Magazynowa",
    "zipCode": "34-443"
  }
}
GET /db/users/_mapping
#DELETE /db/
PUT /db
{
  "mappings": {
    "users" : {
      "properties" : {
        "address" : {
          "type" :    "object",
          "properties": {
            "street": {
              "type": "string"
            },
            "zipCode": {
              "type": "string",
              "index": "not_analyzed"
            }
          }
        },
        "firstname" : {
          "type" :   "string"
        },
        "lastname" : {
          "type" :   "string"
        }
      }
    }
  }
}
# HOW TO ANALYZE BASED ON MAPPING OBJECT TYPE
GET /db/_analyze
{
  "field": "address.zipCode",
  "text" : "45-443"
}

# HOW INNER OBJECT ARE INDEXED BY LUCENE (FLAT LIST KEY-VALUES)
{
  "firstname": "Jan",
  "lastname": "Kowalski",
  "address.street":  "Magazynowa",
  "address.zipCode": "34-443"
}

# ARRAYS OF INNER OBJECTS
POST /twitter/users
{
    "followers": [
        { "age": 35, "name": "Mary White"},
        { "age": 26, "name": "Alex Jones"},
        { "age": 19, "name": "Lisa Smith"}
    ]
}
GET twitter/users/_search
# OBJECT IN LUCENE (the correlation between age:35 and Mary White has been lost)
{
    "followers.age":    [19, 26, 35],
    "followers.name":   [alex, jones, lisa, smith, mary, white]
}

# HOW WE CAN SEARCH ABOUT Alex Jones with age 26?
# CORRELATED INNER OBJECTS - NESTED OBJECTS
PUT /blog/post/1
{
  "title": "Nest eggs",
  "body":  "Making your money work...",
  "tags":  [ "cash", "shares" ],
  "comments": [
    {
      "name":    "John Smith",
      "comment": "Great article",
      "age":     28,
      "stars":   4,
      "date":    "2014-09-01"
    },
    {
      "name":    "Alice White",
      "comment": "More like this please",
      "age":     31,
      "stars":   5,
      "date":    "2014-10-22"
    }
  ]
}

GET /blog/post/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "comments.name": "Alice" }},
        { "match": { "comments.age":  28      }}
      ]
    }
  }
}

DELETE /blog
PUT /blog
{
  "mappings": {
    "post": {
      "properties": {
        "comments": {
          "type": "nested",
          "properties": {
            "name":    { "type": "string"  },
            "comment": { "type": "string"  },
            "age":     { "type": "short"   },
            "stars":   { "type": "short"   },
            "date":    { "type": "date"    }
          }
        }
      }
    }
  }
}

# THE LUCENE STRUCTURE WITH NESTED TYPE (HIDDEN SEPARATE DOCUMENT)
{
  "comments.name":    [ john, smith ],
  "comments.comment": [ article, great ],
  "comments.age":     [ 28 ],
  "comments.stars":   [ 4 ],
  "comments.date":    [ 2014-09-01 ]
}
{
  "comments.name":    [ alice, white ],
  "comments.comment": [ like, more, please, this ],
  "comments.age":     [ 31 ],
  "comments.stars":   [ 5 ],
  "comments.date":    [ 2014-10-22 ]
}
{
  "title":            [ eggs, nest ],
  "body":             [ making, money, work, your ],
  "tags":             [ cash, shares ]
}

# MULTIPLE FIELDS MAPPING
PUT /blog/article/1
{
  "title": "Blog first article"
}
PUT /blog/article/2
{
  "title": "Blog second article"
}
PUT /blog/article/3
{
  "title": "A blog second article"
}

GET /blog/article/_search
{
  "sort": [
    {
      "title": {
        "order": "desc"
      }
    }
  ]
}

PUT /blog
{
  "mappings": {
    "article": {
      "properties": {
        "title": {
          "type": "string",
          "index": "analyzed",
          "fields": {
            "raw": {
              "type": "string",
              "index": "not_analyzed"
            }
          }
        }
      }
    }
  }
}

GET /blog/article/_search
{
  "sort": [
    {
      "title.raw": {
        "order": "desc"
      }
    }
  ]
}



#DEEP DIVE INTO SEARCH (import accounts.json)

GET /bank/account/_search
# QUERY ALL FIELD BY LITE SEARCH
GET /_search?q=mary

# +name:(mary john) +date:>2014-09-10 +(aggregations geo)
# name contains mary or john
# date is greater than
# _all fields contains either of the words

GET /bank/account/_search
{
  "query": { "match_all": {} }
}

#{"query": {
#    QUERY_NAME: {
#        FIELD_NAME: {
#            "VALUE"
#            ARGUMENT: VALUE,
#            ARGUMENT: VALUE,...
#        }
#    }
# }
#}


# QUERIES AND FILTERS - QUERY CONTEXT AND FILTER CONTEX

GET /bank/account/_search?explain
{
  "query": {
    "match": {
      "address": "Newkirk Avenue"
    }
  }
}


# MOST IMPORTANT QUERIES
#  match_all: {}
#  match: {}
#  multi_match: {} - allows to run the same match on multiple fields
GET /bank/account/_search
GET /bank/account/_search
{
  "query": {
    "multi_match": {
      "query": "Putnam Yardville",
      "fields": ["address", "city"]
    }
  }
}
#  range
GET /bank/account/_search
{
  "query": {
    "range": {
      "age" :{
        "gt": 20,
        "lt": 25
      }
    }
  }
}
#  term - IMPORTART THE DIFFERENCES HOW THE ANALYZED / NOT ANALYZED FIELD IS STORED AND THE SEARCH DIFFERENCES
GET /bank/account/_search
{
  "query": {
    "term": {
      "lastname" : "Ayala"
    }
  }
}
GET /bank/account/_search
{
  "query": {
    "match": {
      "lastname" : "Ayala"
    }
  }
}
# LET'S TRY WITH AFTER-ANALYZE FIELD VALUE
GET /bank/account/_search
{
  "query": {
    "term": {
      "lastname" : "ayala"
    }
  }
}
GET /bank/account/_search
{
  "query": {
    "match": {
      "age" : 39
    }
  }
}
GET /bank/account/_search
{
  "query": {
    "term": {
      "gender" : "f"
    }
  }
}


DELETE /db
PUT /db
{
  "mappings": {
    "users" : {
      "properties" : {
        "firstname" : {
          "type" :   "string"
        },
        "lastname" : {
          "type" :   "string"
        },
        "email" : {
          "type": "string",
          "index": "not_analyzed"
        }
      }
    }
  }
}

PUT /db/users/1
{
  "firstname": "Jan",
  "lastname": "Kowalski",
  "email": "jan@wp.pl"
}
#  term
GET /db/users/_search
{
  "query": {
    "term": {
      "email" : "jan@wp.pl"
    }
  }
}

# terms query - the document match if the field contains any of the specified values
GET /db/users/_search
{
  "query": {
    "terms": {
      "email" : ["jan@wp.pl", "janek@sp.pl"]
    }
  }
}

# exist / missing query
GET /db/users/_search
{
  "query": {
    "exists": {
      "field": "email"
    }
  }
}

#COMBINING MULTIPLE CLAUSES (MUST, MUST_NOT, SHOULD,FILTER)
GET /bank/account/_search
{
  "query": {
    "bool": {
      "must": {
        "match": {
          "address": "Avenue"
        }
      },
      "should": {
        "match": {
          "city": "Crawfordsville"
        }
      },
      "must_not": {
        "match": {
          "gender": "F"
        }
      }
    }
  }
}

# USED ARRAY FOR MORE THAN ONE CONDITION
GET /bank/account/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "address": "Avenue"
          }
        },
        {
          "match": {
            "city": "Crawfordsville"
          }
        }
      ]
    }
  }
}

# QUERY WITH FILTER
GET /docusafe/invoice/_search
{
  "query": {
    "bool": {
      "must": {
        "match": {
          "remark": "paid"
        }
      },
      "filter": {
        "range": {
          "amount": {
            "gt": 5
          }
        }
      }
    }
  }
}

GET /bank/account/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "address": "street"
          }
        }
      ],
      "must_not": [
        {
          "match": {
            "gender": "M"
          }
        }
      ],
      "filter": {
        "range": {
          "balance": {
            "gte": 10000,
            "lte": 15000
          }
        }
      }
    }
  }
}

# CONTANT SCORE - IF WE NEED FOR SOME REASON SCORE EQUALS 1 (NOT 0)
GET /bank/account/_search
{
  "query": {
    "constant_score": {
      "filter": {
        "range": {
          "balance": {
            "gte": 10000,
            "lte": 15000
          }
        }
      }
    }
  }
}

# PAGING AND SORTING (THE SCORE IS NULL)
GET /bank/_search
GET /bank/_search
{
  "from": 10,
  "size": 25,
  "_source": [
    "account_number"
  ],
  "sort": [
    {
      "account_number": {
        "order": "asc"
      }
    },
    {
      "age": {
        "order": "desc"
      }
    }
  ]
}

#HIGHLIGTH SENTENCES
GET /bank/account/_search
GET /bank/account/_search
{
    "query" : {
        "match" : {
            "address" : "street"
        }
    },
    "highlight": {
      "fields": {
        "address": {}
      }
    }
}

#BOOSTING
GET /bank/account/_search
{
  "query": {
    "bool": {
      "should": [
        {
          "match": {
            "address": "street"
          }
        },
        {
          "match": {
            "city": {
              "query": "Veguita",
              "boost": 5
            }
          }
        }
      ]
    }
  }
}
DELETE /blog
PUT /blog
{
  "mappings": {
    "post": {
      "properties": {
        "comments": {
          "type": "nested",
          "properties": {
            "name":    { "type": "string"  },
            "comment": { "type": "string"  },
            "age":     { "type": "short"   },
            "stars":   { "type": "short"   },
            "date":    { "type": "date"    }
          }
        }
      }
    }
  }
}

# NESTED OBJECT QUERY
PUT /blog/post/1
{
  "title": "Nest eggs",
  "body":  "Making your money work...",
  "tags":  [ "cash", "shares" ],
  "comments": [
    {
      "name":    "John Smith",
      "comment": "Great article",
      "age":     28,
      "stars":   4,
      "date":    "2014-09-01"
    },
    {
      "name":    "Alice White",
      "comment": "More like this please",
      "age":     31,
      "stars":   5,
      "date":    "2014-10-22"
    }
  ]
}

GET /blog/post/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "title": "eggs"
          }
        },
        {
          "nested": {
            "path": "comments",
            "query": {
              "bool": {
                "must": [
                  {
                    "match": {
                      "comments.name": "smith"
                    }
                  },
                  {
                    "match": {
                      "comments.comment": "great"
                    }
                  }
                ]
              }
            }
          }
        }
      ]
    }
  }
}

# AGGREGATIONS

# Buckets - collections of documents that meet a criterion
# Metrics - statistics calculated on the documents in a bucket

#SELECT COUNT(color) FROM table GROUP BY color

# GROUP BY color -> equivalent of buckets
# COUNT(color) -> equivalent of metrics

POST /cars/transactions/_bulk
{ "index": {}}
{ "price" : 10000, "color" : "red", "make" : "honda", "sold" : "2014-10-28" }
{ "index": {}}
{ "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" }
{ "index": {}}
{ "price" : 30000, "color" : "green", "make" : "ford", "sold" : "2014-05-18" }
{ "index": {}}
{ "price" : 15000, "color" : "blue", "make" : "toyota", "sold" : "2014-07-02" }
{ "index": {}}
{ "price" : 12000, "color" : "green", "make" : "toyota", "sold" : "2014-08-19" }
{ "index": {}}
{ "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" }
{ "index": {}}
{ "price" : 80000, "color" : "red", "make" : "bmw", "sold" : "2014-01-01" }
{ "index": {}}
{ "price" : 25000, "color" : "blue", "make" : "ford", "sold" : "2014-02-12" }

GET /cars/transactions/_search

# BUCKETS BY COLORS
GET /cars/transactions/_search
{
  "size": 0,
  "aggs": {
    "colors": {
      "terms": {
        "field": "color"
      }
    }
  }
}

# BUCKETS BY COLORS WITH AVERANGE PRICE
GET /cars/transactions/_search
{
  "size": 0,
  "aggs": {
    "colors": {
      "terms": {
        "field": "color"
      },
      "aggs": {
        "avg_price": {
          "avg": {
            "field": "price"
          }
        }
      }
    },
    "total_avg_price": {
      "avg": {
        "field": "price"
      }
    }
  }
}

# BUCKETS INSIDE BUCKETS
GET /cars/transactions/_search
{
   "size" : 0,
   "aggs": {
      "colors": {
         "terms": {
            "field": "color"
         },
         "aggs": {
            "avg_price": {
               "avg": {
                  "field": "price"
               }
            },
            "makeBy": {
                "terms": {
                    "field": "make"
                }
            }
         }
      }
   }
}

# METRICS FOR INSIDE BUCKETS
GET /cars/transactions/_search
{
  "size": 0,
  "aggs": {
    "colors": {
      "terms": {
        "field": "color"
      },
      "aggs": {
        "avg_price": {
          "avg": {
            "field": "price"
          }
        },
        "makeBy": {
          "terms": {
            "field": "make"
          },
          "aggs": {
            "min_price": {
              "min": {
                "field": "price"
              }
            },
            "max_price": {
              "max": {
                "field": "price"
              }
            }
          }
        }
      }
    }
  }
}

# EXTENDED STATS
GET /cars/transactions/_search
{
  "size" : 0,
  "aggs": {
    "makes": {
      "terms": {
        "field": "make"
      },
      "aggs": {
        "stats": {
          "extended_stats": {
            "field": "price"
          }
        }
      }
    }
  }
}

# HISTOGRAM - USEFUL FOR BAR CHARTS
GET /cars/transactions/_search
{
  "size": 0,
  "aggs": {
    "price": {
      "histogram": {
        "field": "price",
        "interval": 20000
      },
      "aggs": {
        "revenue": {
          "sum": {
            "field": "price"
          }
        }
      }
    }
  }
}

# DATE-HISTOGRAM
GET /cars/transactions/_search
{
   "size" : 0,
   "aggs": {
      "sales": {
         "date_histogram": {
            "field": "sold",
            "interval": "month",
            "format": "yyyy-MM"
         }
      }
   }
}

# DATE-HISTOGRAM - ADDITIONAL PARAMETERS
GET /cars/transactions/_search
{
   "size" : 0,
   "aggs": {
      "sales": {
         "date_histogram": {
            "field": "sold",
            "interval": "month",
            "format": "yyyy-MM",
            "min_doc_count" : 0,
            "extended_bounds" : {
                "min" : "2014-01",
                "max" : "2014-12"
            }
         }
      }
   }
}

GET /cars/transactions/_search

# SALES BY QUARTERS BY MANUFACTURER
GET /cars/transactions/_search
{
   "size" : 0,
   "aggs": {
      "sales": {
         "date_histogram": {
            "field": "sold",
            "interval": "quarter",
            "format": "yyyy-MM-dd",
            "min_doc_count" : 0,
            "extended_bounds" : {
                "min" : "2014-01-01",
                "max" : "2014-12-31"
            }
         },
         "aggs": {
            "makeBy_sum": {
               "terms": {
                  "field": "make"
               },
               "aggs": {
                  "sum_price": {
                     "sum": { "field": "price" }
                  }
               }
            },
            "total_sum": {
               "sum": { "field": "price" }
            },
            "load_time_outlier" : {
            "percentiles" : {
                "field" : "doc_count"
              }
            }
         }
      }
   }
}

# AGGREGATIONS WITH QUERY
GET /cars/transactions/_search
{
    "query" : {
        "match" : {
            "make" : "ford"
        }
    },
    "aggs" : {
        "colors" : {
            "terms" : {
              "field" : "color"
            }
        }
    }
}
# GLOBAL BUCKET EXAMPLE
GET /cars/transactions/_search
{
    "size" : 0,
    "query" : {
        "match" : {
            "make" : "ford"
        }
    },
    "aggs" : {
        "single_avg_price": {
            "avg" : { "field" : "price" }
        },
        "all": {
            "global" : {},
            "aggs" : {
                "avg_price": {
                    "avg" : { "field" : "price" }
                }

            }
        }
    }
}

#BUCKET FILTERING
GET /cars/transactions/_search
{
  "size": 0,
  "query": {
    "match": {
      "make": "ford"
    }
  },
  "aggs": {
    "recent_sales": {
      "filter": {
        "range": {
          "sold": {
            "from": "now-1y"
          }
        }
      },
      "aggs": {
        "average_price": {
          "avg": {
            "field": "price"
          }
        }
      }
    },
    "all_time_average_price": {
      "avg": {
        "field": "price"
      }
    }
  }
}

# POST FILTER - filter just the search results but not the aggregation
GET /cars/transactions/_search
{
    "query": {
        "match": {
            "make": "ford"
        }
    },
    "post_filter": {
        "term" : {
            "color" : "green"
        }
    },
    "aggs" : {
        "all_colors": {
            "terms" : { "field" : "color" }
        }
    }
}

# RECAP
# query clause affects both search results and aggregations
# filter bucket affects just aggregations.
# post_filter affects just search results.

# BUCKET SORTING
# by default, buckets are ordered by doc_count in descending order

# INTRINSIC SORTING (WEWNĘTRZNY)
GET /cars/transactions/_search
{
    "size" : 0,
    "aggs" : {
        "colors" : {
            "terms" : {
              "field" : "color",
              "order": {
                "_count" : "desc"
              }
            }
        }
    }
}

# _count - sort by document count, works with terms, histogram, date_histogram
# _term - sort by the string value of a term alphabetically, works only with terms
# _key - sort by the numeric value of each bucket’s key (conceptually similar to _term), works only with histogram and date_histogram

# SORT BY METRICS
GET /cars/transactions/_search
{
    "size" : 0,
    "aggs" : {
        "colors" : {
            "terms" : {
              "field" : "color",
              "order": {
                "avg_price" : "asc"
              }
            },
            "aggs": {
                "avg_price": {
                    "avg": {"field": "price"}
                }
            }
        }
    }
}

# Approximate Aggregations
GET /cars/transactions/_search
{
    "size" : 0,
    "aggs" : {
        "distinct_colors" : {
            "cardinality" : {
              "field" : "color"
            }
        }
    }
}

# TRANSPORT CLIENT vs NODE CLIENT

# Transport client
# - act as a communication layer between the cluster and application
# - it knows the API and can automatically round-robin between nodes
# - it is external to the custer similar to the REST clients

# Node client
# - is acutally a node within the cluster (but does not hold data and cannot become a master)
# - because it is a node it knows the entire cluster state (where all the nodes reside, which shards live in which nodes, etc.)

DELETE /_all
GET /db/person/_search
GET /db/_mappings
GET _cat/indices?v
GET /twitter/_search
